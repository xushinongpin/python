如果你需要迭代一系列数字，内置函数 range\(\)就派上用场了。它生成算术进度：

```
>>> for i in range(5):
...     print(i)
...
0
1
2
3
4
>>>
```

给定的终点永远不是生成序列的一部分; range\(10\)生成10个值，长度为10的序列的项目的合法索引。可以让范围从另一个数字开始，或者指定不同的增量（甚至是负数;有时这称为“步骤”）：

```
>>> for i in range(5,10):
...     print(i,end='|-|')
...
5|-|6|-|7|-|8|-|9|-|>>>
>>> for i in range(0,10,3):
...     print(i,end='|-|')
...
0|-|3|-|6|-|9|-|>>>
>>> for i in range(-10,-110,-30):
...     print(i,end='|-|')
...
-10|-|-40|-|-70|-|-100|-|>>>
```

要迭代序列的索引，您可以组合range\(\)并 len\(\)如下：

```
>>> a = ['Mary','had','a','little','lamb']
>>> for i in range (len(a)):
...     print(i,a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
>>>
```

但是，在大多数此类情况下，使用该[enumerate\(\) ](https://docs.python.org/3/library/functions.html#enumerate)函数很方便，请参阅[循环技术](https://docs.python.org/3/tutorial/datastructures.html#tut-loopidioms)。

如果你只打印一个范围，就会发生一件奇怪的事：

```
>>> print(range(10))
range(0, 10)
>>> 
```

在许多方面，返回的对象range\(\)表现得好像它是一个列表，但事实上并非如此。它是一个对象，当您迭代它时，它返回所需序列的连续项，但它并不真正使列表，从而节省空间。

我们说这样的对象是可迭代的，也就是说，适合作为函数和构造的目标，这些函数和构造期望在供应耗尽之前它们可以从中获得连续的项目。我们已经看到该for语句是一个迭代器。功能list\(\) 是另一个; 它从迭代创建列表：

```
>>> list(range(5))
[0, 1, 2, 3, 4]
>>>

```



