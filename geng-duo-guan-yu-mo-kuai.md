## 更多关于模块

模块可以包含可执行语句以及函数定义。这些语句用于初始化模块。它们仅在第一次在import语句中遇到模块名时执行。 （如果文件作为脚本执行，它们也会运行。）

每个模块都有自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块中使用全局变量，而不必担心与用户的全局变量的意外冲突。另一方面，如果您知道自己在做什么，则可以使用与其函数相同的符号来触摸模块的全局变量modname.itemname。

模块可以导入其他模块。习惯但不要求将所有 import语句放在模块的开头（或脚本，就此而言）。导入的模块名称放在导入模块的全局符号表中。

该import语句的变体将模块中的名称直接导入导入模块的符号表。例如：

```
>>> from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>>
```

这不会引入从本地符号表中获取导入的模块名称（因此在示例中fibo未定义）。

甚至还有一个变体来导入模块定义的所有名称：

```
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>>
```

这将导入除以下划线（\_）开头的所有名称。在大多数情况下，Python程序员不使用此工具，因为它在解释器中引入了一组未知的名称，可能隐藏了您已定义的一些内容。

请注意，一般来说，\*从模块或包导入的做法是不受欢迎的，因为它经常会导致代码难以理解。但是，可以使用它来保存交互式会话中的输入。

如果后跟模块名称as，则以下名称as将直接绑定到导入的模块。

```
>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>>
```

这实际上是以与 将要执行的方式相同的方式导入模块。import fibofib

在使用from具有类似效果时也可以使用它：

```
>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
>>>
```

注意

出于效率原因，每个模块仅在每个解释器会话中导入一次。因此，如果更改模块，则必须重新启动解释器 - 或者，如果只是一个模块要进行交互式测试，请使用[`importlib.reload()`](https://docs.python.org/3/library/importlib.html#importlib.reload)，例如。`importimportlib;importlib.reload(modulename)`

