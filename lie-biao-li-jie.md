### 列表理解

列表推导提供了创建列表的简明方法。常见的应用是创建新的列表，其中每个元素是应用于另一个序列的每个成员或可迭代的一些操作的结果，或者创建满足特定条件的那些元素的子序列。

例如，假设我们要创建一个平方列表，例如：

```
>>> squares = []
>>> for x in range(10):
...     squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>>
```

请注意，这会创建（或覆盖）一个名为x在循环完成后仍然存在的变量。我们可以使用以下方法计算没有任何副作用的正方形列表：

```
>>> squares = list(map(lambda x: x**2, range(20)))
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225, 256, 289, 324, 361]
或者，等效地：
>>> squares = [x**2 for x in range(15)]
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196]
>>>
```

这更简洁，更易读。

列表推导由括号组成，括号中包含一个表达式，后跟一个for子句，然后是零个或多个for或if 子句。结果将是一个新的列表，该列表是通过在其后面的for和if子句的上下文中评估表达式而得到的。例如，如果列表不相等，则此listcomp将两个列表的元素组合在一起：

```
>>> [(x,y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
相当于：
>>> combs = []
>>> for x in [1,2,3]:
...     for y in [3,1,4]:
...             if x != y:
...                     combs.append((x,y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
>>>
```

请注意这两个片段中for和if语句的顺序是如何相同的。

如果表达式是元组（例如前面示例中的元组），则必须将其括起来。\(x, y\)

```
>>> vec = [-4,-2,0,2,4]
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> [x for x in vec if x = 0]
[0, 2, 4]
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>>
 freshfruit = [' banana',' loganberry ','passion fruit ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> [(x,x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> ＃元组必须加括号，否则会引发错误
>>> [x,x**2 for x in range(6)]
  File "<stdin>", line 1
    [x,x**2 for x in range(6)]
              ^
SyntaxError: invalid syntax
>>> vec = [[1,2,3],[4,5,6],[7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>>
```

列表推导可以包含复杂的表达式和嵌套函数：

```
>>> from math import pi
>>> [str(round(pi,i)) for i in range(1,6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
>>>
```



